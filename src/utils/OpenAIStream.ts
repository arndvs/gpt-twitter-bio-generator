/*
OpenAIStream returns a ReadableStream object of chat messages generated by the OpenAI API.
The function takes a payload object with parameters that configure the behavior of the chatbot,
including the maximum number of tokens in the generated messages, the temperature of the language
model, and penalties for repetition and presence of certain words.

The function sends a POST request to the OpenAI API with the given payload, and reads the stream
of chat messages returned by the API as an SSE stream. The function parses each SSE event and
extracts the text content of the response, encoding the text as bytes and enqueuing it in the
ReadableStream object. The function returns the ReadableStream object, which can be used to
consume the chat messages generated by the OpenAI API.
*/

// Import the necessary modules from the "eventsource-parser" library
import {
  createParser,
  ParsedEvent,
  ReconnectInterval
} from 'eventsource-parser';

// Define the possible values for the 'role' property in the 'ChatGPTMessage' interface
export type ChatGPTAgent = 'user' | 'system';

// Define the shape of a chat message for the OpenAI API
export interface ChatGPTMessage {
  role: ChatGPTAgent;
  content: string;
}

// Define the shape of the request payload for the OpenAI API stream
export interface OpenAIStreamPayload {
  model: string;
  messages: ChatGPTMessage[];
  temperature: number;
  top_p: number;
  frequency_penalty: number;
  presence_penalty: number;
  max_tokens: number;
  stream: boolean;
  n: number;
}

// Define the OpenAIStream function that returns a readable stream of chat messages
export async function OpenAIStream(payload: OpenAIStreamPayload) {
  // Check if the OPENAI_API_KEY environment variable is set
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OpenAI API key is missing');
  }

  // Create new TextEncoder and TextDecoder objects to encode/decode strings as bytes
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  // Counter to keep track of the number of messages read from the OpenAI stream
  let counter = 0;

  // Send a POST request to the OpenAI API with the given payload
  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    headers: {
      // Include the OpenAI API key in the Authorization header
      'Content-Type': 'application/json',
      Authorization: `Bearer ${process.env.OPENAI_API_KEY ?? ''}`
    },
    method: 'POST',
    body: JSON.stringify(payload)
  });

  // Throw an error if the fetch request fails
  if (!res.ok) {
    throw new Error(
      `OpenAI API request failed: ${res.status} ${res.statusText}`
    );
  }

  // Define a ReadableStream object that reads data from the SSE stream returned by OpenAI
  const stream = new ReadableStream({
    async start(controller) {
      // Callback function that is invoked for each SSE event
      function onParse(event: ParsedEvent | ReconnectInterval) {
        if (event.type === 'event') {
          const data = event.data;
          // Check if the message is a "[DONE]" signal indicating the end of the stream
          if (data === '[DONE]') {
            // Close the stream
            controller.close();
            return;
          }
          try {
            // Parse the message as JSON and extract the text content of the response
            const json = JSON.parse(data);
            const text = json.choices[0].delta?.content || '';
            // Check if the message is a prefix character and ignore it if so
            if (counter < 2 && (text.match(/\n/) || []).length) {
              // This is a prefix character (i.e., "\n\n"), do nothing
              return;
            }
            // Encode the text content as bytes and enqueue it in the stream
            const queue = encoder.encode(text);
            controller.enqueue(queue);
            // Increment the message counter
            counter++;
          } catch (e) {
            // Handle any parsing errors by forwarding the error to the stream controller
            controller.error(e);
          }
        }
      }

      // Create a parser that invokes the onParse callback for each SSE event in the stream
      const parser = createParser(onParse);

      // Read chunks of data from the SSE stream and pass them to the parser for processing
      let reader = res.body?.getReader();
      if (!reader) {
        throw new Error('Failed to get stream reader');
      }

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            // The stream has ended unexpectedly
            throw new Error('OpenAI API stream ended unexpectedly');
          }
          // Decode the chunk of data as a string and feed it to the parser
          parser.feed(decoder.decode(value));
        }
      } catch (e) {
        // Handle any errors thrown by the stream reader or parser
        controller.error(e);
      } finally {
        // Cancel the stream reader to clean up resources
        reader.cancel();
      }
    }
  });

  // Return the readable stream object
  return stream;
}
